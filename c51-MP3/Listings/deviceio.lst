C51 COMPILER V9.60.0.0   DEVICEIO                                                          06/16/2023 01:03:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DEVICEIO
OBJECT MODULE PLACED IN .\Objects\deviceio.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE deviceio.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\deviceio.lst) TABS(2) OBJECT(.\Objects\deviceio.obj)

line level    source

   1          
   2          #include "config.h"
   3          #include "deviceio.h"
   4          
   5          #include "sd.h" //´æ´¢Éè±¸Çı¶¯Í·ÎÄ¼ş
   6          
   7          struct znFAT_IO_Ctl ioctl; //ÓÃÓÚÉÈÇø¶ÁĞ´µÄIO¿ØÖÆ£¬¾¡Á¿¼õÉÙÎïÀíÉÈÇø²Ù×÷£¬Ìá¸ßĞ§ÂÊ
   8          extern UINT8 Dev_No; //Éè±¸ºÅ
   9          extern UINT8 *znFAT_Buffer;
  10          
  11          /*******************************************************************
  12           ¹¦ÄÜ£º´æ´¢Éè±¸³õÊ¼»¯
  13           ĞÎ²Î£ºÎŞĞÎ²Î
  14           ·µ»Ø£º´æ´¢Éè±¸³õÊ¼»¯´íÎóĞÅÏ¢
  15           Ïê½â£ºznFATÖ§³Ö¶àÉè±¸£¬¼´Í¬Ê±¹Ò½Ó¶àÖÖ´æ´¢Éè±¸£¬ËùÓĞ´æ´¢Éè±¸µÄ³õÊ¼
  16                 »¯¾ùÔÚÕâÀïÍê³É¡£·µ»ØÖµµÄÄ³Ò»Î»Îª1£¬ÔòËµÃ÷ÏàÓ¦µÄ´æ´¢Éè±¸³õÊ¼
  17                 »¯Ê§°Ü¡£ÀıÈç£ºÉè±¸0Ê§°Ü£¬¶øÆäËüÉè±¸¾ù³É¹¦£¬Ôò·µ»ØÖµÎª0X01¡¢
  18                 Éè±¸1ÓëÉè±¸2Ê§°Ü£¬¶øÆäËüÉè±¸³É¹¦£¬Ôò·µ»ØÖµÎª0X06¡£ÎªÁËÊ¹·µ»Ø
  19                 ÖµÈçÊµµÄ·´Ó³ÏàÓ¦Éè±¸µÄ³õÊ¼»¯×´Ì¬£¬Çë×¢Òâ´æ´¢Éè±¸³õÊ¼»¯º¯Êı
  20                 µ÷ÓÃµÄË³Ğò¡£
  21          *******************************************************************/
  22          
  23          UINT8 znFAT_Device_Init(void) 
  24          {
  25   1       UINT8 res=0,err=0;
  26   1      
  27   1       ioctl.just_dev=0;
  28   1       ioctl.just_sec=0;
  29   1      
  30   1       //ÒÔÏÂÎª¸÷´æ´¢Éè±¸µÄ³õÊ¼»¯º¯Êıµ÷ÓÃ£¬ÇëÑØÏ®ÒÔÏÂ¸ñÊ½
  31   1      
  32   1       res=SD_Ready_Go(); 
  33   1       if(res) err|=0X01;
  34   1      
  35   1       //res=Device1_Init();
  36   1       //if(res) err|=0X02;
  37   1      
  38   1       return err; //·µ»Ø´íÎóÂë£¬Èç¹ûÄ³Ò»Éè±¸³õÊ¼»¯Ê§°Ü£¬ÔòerrÏàÓ¦Î»Îª1
  39   1      }
  40          
  41          /*****************************************************************************
  42           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇø¶ÁÈ¡Çı¶¯½Ó¿Ú
  43           ĞÎ²Î£ºaddr:ÎïÀíÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
  44           ·µ»Ø£º0
  45           Ïê½â£º¸÷´æ´¢Éè±¸µÄÎïÀíÉÈÇø¶ÁÈ¡Çı¶¯º¯Êı·Åµ½caseµÄ¸÷¸ö·ÖÖ§ÖĞ£¬·ÖÖ§ĞòºÅ¾ÍÊÇ´ËÉè
  46                 ±¸µÄÉè±¸ºÅ¡£ 
  47          *****************************************************************************/
  48          UINT8 znFAT_Device_Read_Sector(UINT32 addr,UINT8 *buffer)
  49          {
  50   1       if(buffer==znFAT_Buffer) //Èç¹ûÊÇÕë¶ÔznFATÄÚ²¿»º³åÇøµÄ²Ù×÷
  51   1       {                        
  52   2        if(ioctl.just_dev==Dev_No  //Èç¹ûÏÖÔÚÒª¶ÁÈ¡µÄÉÈÇøÓëÄÚ²¿»º³åËù¶ÔÓ¦µÄÉÈÇø£¨¼´×î½üÒ»´Î²Ù×÷µÄÉÈÇø£©ÊÇÍ¬Ò»ÉÈÇ
             -ø
  53   2           && (ioctl.just_sec==addr && 0!=ioctl.just_sec)) //Ôò²»ÔÙ½øĞĞ¶ÁÈ¡£¬Ö±½Ó·µ»Ø
C51 COMPILER V9.60.0.0   DEVICEIO                                                          06/16/2023 01:03:55 PAGE 2   

  54   2        {                                           
  55   3         return 0;      
  56   3        }
  57   2        else //·ñÔò£¬¾Í½«×î½üÒ»´Î²Ù×÷µÄÉÈÇø±ê¼ÇÎªµ±Ç°ÉÈÇø
  58   2        {
  59   3         ioctl.just_dev=Dev_No; 
  60   3         ioctl.just_sec=addr; 
  61   3        }
  62   2       }
  63   1      
  64   1       switch(Dev_No) //ÓĞ¶àÉÙ¸ö´æ´¢Éè±¸£¬¾ÍÓĞ¶àÉÙ¸öcase·ÖÖ§
  65   1       {
  66   2        case 0:
  67   2               while(SD_Read_Sector(addr,buffer));
  68   2               break;
  69   2        //case 1:
  70   2      //       while(SD2_Read_Sector(addr,buffer));
  71   2      //       break;
  72   2        //case...
  73   2        
  74   2       }
  75   1      
  76   1       return 0;
  77   1      }
  78          
  79          /*****************************************************************************
  80           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøĞ´ÈëÇı¶¯½Ó¿Ú
  81           ĞÎ²Î£ºaddr:ÎïÀíÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
  82           ·µ»Ø£º0
  83           Ïê½â£º¸÷´æ´¢Éè±¸µÄÎïÀíÉÈÇøĞ´ÈëÇı¶¯º¯Êı·Åµ½caseµÄ¸÷¸ö·ÖÖ§ÖĞ£¬·ÖÖ§ĞòºÅ¾ÍÊÇ´ËÉè
  84                 ±¸µÄÉè±¸ºÅ¡£ 
  85          *****************************************************************************/
  86          UINT8 znFAT_Device_Write_Sector(UINT32 addr,UINT8 *buffer) 
  87          {
  88   1       if(buffer==znFAT_Buffer) //Èç¹ûÊı¾İ»º³åÇøÊÇÄÚ²¿»º³å
  89   1       {
  90   2        ioctl.just_dev=Dev_No; //¸üĞÂÎªµ±Ç°Éè±¸ºÅ
  91   2        ioctl.just_sec=addr; //¸üĞÂÎªµ±Ç°²Ù×÷µÄÉÈÇøµØÖ· 
  92   2       }
  93   1      
  94   1       switch(Dev_No)
  95   1       {
  96   2        case 0:
  97   2               while(SD_Write_Sector(addr,buffer));
  98   2               break;
  99   2        //case 1:
 100   2      //       while(SD2_Write_Sector(addr,buffer));
 101   2      //       break;
 102   2        //case...
 103   2        
 104   2       } 
 105   1      
 106   1       return 0;
 107   1      }
 108          
 109          /***********************************************************************************
 110           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬Ğø¶ÁÈ¡Çı¶¯½Ó¿Ú
 111           ĞÎ²Î£ºnsec:Òª¶ÁÈ¡µÄÉÈÇøÊı addr:Á¬ĞøÉÈÇø¶ÁÈ¡Ê±µÄ¿ªÊ¼ÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
 112           ·µ»Ø£º0
 113           Ïê½â£º´Ëº¯Êı½Ó¿ÚÔÚznFATÖĞÓÃÓÚÍê³ÉÈô¸É¸öÁ¬ĞøÉÈÇøµÄÒ»´ÎĞÔ¶ÁÈ¡¡£´Ëº¯Êı½Ó¿ÚµÄÊµÏÖÓĞÁ½ÖÖ
 114                 Ä£Ê½ 1¡¢µ¥ÉÈÇø¶ÁÈ¡Çı¶¯+Ñ­»· 2¡¢´æ´¢Éè±¸Ó²¼şÉÏµÄÁ¬ĞøÉÈÇø¶ÁÈ¡ Ê¹ÓÃ2±È1µÄĞ§ÂÊÒª
 115                 µÃ¶à£¬ÔÚ¸ßËÙÇÒÊı¾İÁ¿±È½Ï´óµÄÓ¦ÓÃ³¡ºÏ£¬½¨ÒéÊ¹ÓÃÕßÌá¹©Ó²¼ş¼¶µÄÁ¬ĞøÉÈÇø¶ÁÈ¡º¯Êı
C51 COMPILER V9.60.0.0   DEVICEIO                                                          06/16/2023 01:03:55 PAGE 3   

 116          ***********************************************************************************/
 117          UINT8 znFAT_Device_Read_nSector(UINT32 nsec,UINT32 addr,UINT8 *buffer)
 118          {
 119   1       UINT32 i=0;
 120   1      
 121   1       if(0==nsec) return 0;
 122   1      
 123   1       #ifndef USE_MULTISEC_R //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇø¶ÁÈ¡Çı¶¯
 124   1      
 125   1        switch(Dev_No)
 126   1        {
 127   2         case 0:
 128   2                for(i=0;i<nsec;i++) //Èç¹û²»Ê¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇø¶ÁÈ¡£¬ÔòÊ¹ÓÃµ¥ÉÈÇø¶ÁÈ¡+Ñ­»·µÄ·½Ê½
 129   2                {
 130   3                 while(SD_Read_Sector(addr+i,buffer));
 131   3                 buffer+=512;
 132   3                }
 133   2                break;
 134   2        // case 1:
 135   2         //       for(i=0;i<nsec;i++) //Èç¹û²»Ê¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇø¶ÁÈ¡£¬ÔòÊ¹ÓÃµ¥ÉÈÇø¶ÁÈ¡+Ñ­»·µÄ·½Ê½
 136   2        //        {
 137   2         //        while(SD2_Read_Sector(addr+i,buffer));
 138   2         //        buffer+=512;
 139   2         //       }
 140   2        //        break;
 141   2        }
 142   1      
 143   1       #else
              
                switch(Dev_No)
                {
                 case 0:
                        while(Device0_Read_nSector(nsec,addr,buffer));
                 //case 1:
                        //while(Device1_Read_nSector(nsec,addr,buffer));
                }
               #endif
 153   1      
 154   1       return 0;
 155   1      }
 156          
 157          /***********************************************************************************
 158           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬ĞøĞ´ÈëÇı¶¯½Ó¿Ú
 159           ĞÎ²Î£ºnsec:ÒªĞ´ÈëµÄÉÈÇøÊı addr:Á¬ĞøÉÈÇøĞ´ÈëÊ±µÄ¿ªÊ¼ÉÈÇøµØÖ· buffer:Êı¾İ»º³åÇøÖ¸Õë
 160           ·µ»Ø£º0
 161           Ïê½â£º´Ëº¯Êı½Ó¿ÚÓëÉÏÃæµÄÁ¬Ğø¶ÁÈ¡Çı¶¯½Ó¿ÚÍ¬Àí¡£
 162          ***********************************************************************************/
 163          UINT8 znFAT_Device_Write_nSector(UINT32 nsec,UINT32 addr,UINT8 *buffer)
 164          {
 165   1       UINT32 i=0;
 166   1       
 167   1       if(0==nsec) return 0;
 168   1      
 169   1       #ifndef USE_MULTISEC_W //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼şµÄÁ¬ĞøÉÈÇøĞ´Èëº¯Êı
 170   1      
 171   1        switch(Dev_No)
 172   1        {
 173   2         case 0:
 174   2                for(i=0;i<nsec;i++)
 175   2                {
 176   3                 while(SD_Write_Sector(addr+i,buffer));
 177   3                 buffer+=512;
C51 COMPILER V9.60.0.0   DEVICEIO                                                          06/16/2023 01:03:55 PAGE 4   

 178   3                }
 179   2            break;
 180   2         //case 1:
 181   2         //       for(i=0;i<nsec;i++)
 182   2         //       {
 183   2         //        while(SD2_Write_Sector(addr+i,buffer));
 184   2         //        buffer+=512;
 185   2          //      }
 186   2      //      break;
 187   2        }
 188   1        
 189   1       #else
              
                switch(Dev_No)
                {
                 case 0:
                        while(SD_Write_nSector(nsec,addr,buffer));
                    break;
                 //case 1:
                        //while(Device1_Write_nSector(nsec,addr,buffer));
                }
              
               #endif
 201   1      
 202   1       return 0; 
 203   1      }
 204          
 205          /***********************************************************************************
 206           ¹¦ÄÜ£ºznFATµÄ´æ´¢Éè±¸ÎïÀíÉÈÇøÁ¬ĞøÇå0Çı¶¯½Ó¿Ú
 207           ĞÎ²Î£ºnsec:ÒªÇå0µÄÉÈÇøÊı addr:Á¬ĞøÉÈÇøÇå0µÄ¿ªÊ¼ÉÈÇøµØÖ·
 208           ·µ»Ø£º0
 209           Ïê½â£ºÔÚ¸ñÊ½»¯¹¦ÄÜÖĞ£¬×îºÄÊ±µÄ¾ÍÊÇ¶ÔFAT±íÉÈÇøÉÈÇøµÄÖğ¸öÇå0£¬Ê¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇøÇå0
 210                 Çı¶¯º¯Êı½«¿ÉÒÔºÜ´ó³Ì¶ÈÉÏ¼ÓËÙÕâÒ»¹ı³Ì¡£
 211          ***********************************************************************************/
 212          UINT8 znFAT_Device_Clear_nSector(UINT32 nsec,UINT32 addr)
 213          {
 214   1       #ifndef USE_MULTISEC_CLEAR  //´Ëºê¾ö¶¨ÊÇ·ñÊ¹ÓÃÓ²¼ş¼¶Á¬ĞøÉÈÇøÇå0º¯Êı£¬ÆäÖ÷ÒªÓÃÓÚ¸ñÊ½»¯¹ı³ÌÖĞFAT±íµÄÇå0
 215   1        UINT32 i=0;
 216   1      
 217   1        for(i=0;i<512;i++) //Çå¿ÕÄÚ²¿»º³åÇø£¬ÓÃÓÚÁ¬ĞøÉÈÇøÇå0
 218   1        {
 219   2         znFAT_Buffer[i]=0;
 220   2        }
 221   1      
 222   1        switch(Dev_No)
 223   1        {
 224   2         case 0:
 225   2                for(i=0;i<nsec;i++)
 226   2                {
 227   3                 while(SD_Write_Sector(addr+i,znFAT_Buffer));
 228   3                }
 229   2                break;
 230   2         //case 1:
 231   2         //       for(i=0;i<nsec;i++)
 232   2         //       {
 233   2          //       while(SD2_Write_Sector(addr+i,znFAT_Buffer));
 234   2         //       }
 235   2         //       break;
 236   2        }
 237   1      
 238   1       #else
              
C51 COMPILER V9.60.0.0   DEVICEIO                                                          06/16/2023 01:03:55 PAGE 5   

                switch(Dev_No)
                {
                 case 0:
                        return Device0_Clear_nSector(nsec,addr); //ÔÚÊ¹ÓÃÓ²¼ş¼¶µÄÁ¬ĞøÉÈÇøÇå0µÄÊ±ºò£¬Çë½«Á¬ĞøÉÈÇøÇå0º¯ÊıĞ
             -´ÔÚÕâÀï
                 //case 1:
                        //return Device1_Clear_nSector(nsec,addr);
                }
              
               #endif
 249   1      
 250   1       ioctl.just_dev=Dev_No; //¸üĞÂÎªµ±Ç°Éè±¸ºÅ
 251   1       ioctl.just_sec=(addr+nsec-1); //¸üĞÂÎªµ±Ç°²Ù×÷µÄÉÈÇøµØÖ·  
 252   1      
 253   1       return 0;  
 254   1      }
 255          
 256          //==============================¡¾ÒÔÉÏÊÇÉè±¸Çı¶¯²ã¡¿======================================================
             -==================
 257          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1085    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5      57
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
