#include "1003b.h"
#include <intrins.h>
#include "SD.h"
#include "string.h"
#include	"STC8A_SPI.h"



#define uchar unsigned char
#define uint unsigned int
#define ulong unsigned long
#define bool bit
#define true 1
#define flase 0



#define Macro_Set_SI_High()  	c_SPI_SI = 1
#define Macro_Set_SI_Low()  	c_SPI_SI = 0
#define Macro_Set_CLK_High()  	c_SPI_CLK = 1
#define Macro_Set_CLK_Low()  	c_SPI_CLK = 0




void wait(uchar ucDelayCount)
{
	uchar ucTempCount;
	uchar uci;

	for(ucTempCount=0; ucTempCount<ucDelayCount; ucTempCount++)
	{
//		uci = 200;	//Err
//		uci = 250;	//OK
		uci = 230;
		while(uci--)
		{
			_nop_();
	   	}
	}
}

//#define wait(x) Delay(x)
/**********************************************************/
/*  函数名称 :   MSPI_Init                                */
/*  函数功能 ： 初始化SPI接口，设置为主机。               */
/*  参数     :  无                                        */
/*  返回值   :  无                                        */
/*--------------------------------------------------------*/
void  MSPI_Init(void)
{  
/*
	PINSEL0 = (PINSEL0 & 0xFFFF00FF) | 0x00005500;	//选择 SPI 
        S0SPCCR = 0x08;		                        // SPI 时钟设置
 	S0SPCR  = (0 << 3) |				// CPHA = 0, 
 		  (0 << 4) |				// CPOL = 0, 
 		  (1 << 5) |				// MSTR = 1, 
 		  (0 << 6) |				// LSBF = 0, 
 	          (0 << 7);				// SPIE = 0, 
*/
	c_SPI_SO = 1;
	MP3_DREQ = 1;

}

/**********************************************************/
/*  函数名称 :  InitPortVS1003                            */
/*  函数功能 ： MCU与vs1003接口的初始化                   */
/*  参数     :  无                                        */
/*  返回值   :  无                                        */
/*--------------------------------------------------------*/
void  InitPortVS1003(void)
{
	MSPI_Init();//SPI口的初始化
//	IODIR &= 0xfffeffff;   //其他接口线的设置，其中dreq 为输入口
//	IODIR |= MP3_XRESET | MP3_XCS | MP3_XDCS;//xRESET，xCS，xDS均为输出口
//	IOSET |= MP3_XRESET | MP3_XCS | MP3_XDCS;//xRESET，xCS，xDS默认输出高电平	
	MP3_DREQ = 1;		//置为输入

	MP3_XRESET = 1;
	MP3_XCS = 1;
	MP3_XDCS = 1;
}

//uint8 SD_SPI_ReadByte(void);
//void SD_SPI_WriteByte(uint8 ucSendData);

//#define SPI_RecByte()  SD_SPI_ReadByte()
//#define SPIPutChar(x) SD_SPI_WriteByte(x)

#if 1
/**********************************************************/
/*  函数名称 :  SPIPutChar                                */
/*  函数功能 ： 通过SPI发送一个字节的数据                 */
/*  参数     :  待发送的字节数据                          */
/*  返回值   :  无                                        */
/*--------------------------------------------------------*/
void  SPIPutChar(unsigned char ucSendData)
{      
		SPI_WriteByte(ucSendData);


//	uchar ucCount;
//	uchar ucMaskCode;

//	ucMaskCode = 0x80;
//	for(ucCount=0; ucCount<8; ucCount++)
//	{
//		Macro_Set_CLK_Low();

//		if(ucMaskCode & ucSendData)
//		{
//			Macro_Set_SI_High();
//		}
//		else
//		{
//			Macro_Set_SI_Low();
//		}

//		Macro_Set_CLK_High();
//		ucMaskCode >>= 1;

//	}
}

/*******************************************************************************************************************
** 函数名称: INT8U SPI_RecByte()				Name:	  INT8U SPI_RecByte()
** 功能描述: 从SPI接口接收一个字节				Function: receive a byte from SPI interface
** 输　  入: 无									Input:	  NULL
** 输 　 出: 收到的字节							Output:	  the byte that be received
********************************************************************************************************************/
static uchar SPI_RecByte(void)
{
//	uchar ucReadData;
//	uchar ucCount;

//	ucReadData = 0;
//	Macro_Set_SI_High();

//	for(ucCount=0; ucCount<8; ucCount++)
//	{
//		ucReadData <<= 1;
//			//降低时钟频率
//		Macro_Set_CLK_Low();

//	
//		if(c_SPI_SO)
//		{
//			ucReadData |= 0x01;
//		}
//		Macro_Set_CLK_High();

//	}

//	return(ucReadData);
    return (SPI_ReadByte());
}

#endif

/*************************************************************/
/*  函数名称 :  Mp3WriteRegister                             */
/*  函数功能 ： 写vs1003寄存器                               */
/*  参数     :  寄存器地址，待写数据的高8位，待写数据的低8位 */
/*  返回值   :  无                                           */
/*-----------------------------------------------------------*/
void Mp3WriteRegister(unsigned char addressbyte, unsigned char highbyte, unsigned char lowbyte)
{
	Mp3DeselectData();
	Mp3SelectControl();//XCS = 0
	SPIPutChar(VS_WRITE_COMMAND); //发送写寄存器命令
	SPIPutChar(addressbyte);      //发送寄存器的地址
	SPIPutChar(highbyte);         //发送待写数据的高8位
	SPIPutChar(lowbyte);          //发送待写数据的低8位
	Mp3DeselectControl();
}

/*************************************************************/
/*  函数名称 :  Mp3ReadRegister                              */
/*  函数功能 ： 写vs1003寄存器                               */
/*  参数     :  寄存器地址				     */
/*  返回值   :  vs1003的16位寄存器的值                       */
/*-----------------------------------------------------------*/
unsigned int Mp3ReadRegister(unsigned char addressbyte)
{
	unsigned int resultvalue = 0;
	uchar ucReadValue;

	Mp3DeselectData();
	Mp3SelectControl();//XCS = 0
	SPIPutChar(VS_READ_COMMAND); //发送读寄存器命令
	SPIPutChar((addressbyte));	 //发送寄存器的地址

//	SPIPutChar(0xff); 		//发送读时钟
//	resultvalue = (SPI_RESULT_BYTE) << 8;//读取高8位数据
	ucReadValue = SPI_RecByte();
	resultvalue = ucReadValue<<8;
//	SPIPutChar(0xff);		   //发送读时钟
//	resultvalue |= (SPI_RESULT_BYTE);  //读取低8位数据
	ucReadValue = SPI_RecByte();
	resultvalue |= ucReadValue;

	Mp3DeselectControl();              
	return resultvalue;                 //返回16位寄存器的值
}

/**********************************************************/
/*  函数名称 :  Mp3SoftReset                              */
/*  函数功能 ： vs1003软件复位                            */
/*  参数     :  无                                        */
/*  返回值   :  无                                        */
/*--------------------------------------------------------*/

void Mp3SetVolume1(unsigned char num)  //0xXX
	{
		Mp3WriteRegister(SPI_VOL,num,num);//设置音量
	}
void Mp3SoftReset(void)
{
	Mp3WriteRegister (SPI_MODE, 0x08, 0x04); //软件复位

	wait(1); //延时1ms
	while (MP3_DREQ == 0); //等待软件复位结束
	Mp3WriteRegister(SPI_CLOCKF, 0x98, 0x00);//设置vs1003的时钟,3倍频
	Mp3WriteRegister (SPI_AUDATA, 0xAC, 0x44); //采样率48k，立体声
	Mp3WriteRegister(SPI_BASS, 0x00, 0x55);//设置重音
	Mp3WriteRegister(SPI_VOL,0x55,0x55);//设置音量
    wait(1); //延时1ms
    	
    	//向vs1003发送4个字节无效数据，用以启动SPI发送
   	Mp3SelectData();
	SPIPutChar(0);
	SPIPutChar(0);
	SPIPutChar(0);
	SPIPutChar(0);
	Mp3DeselectData();

}
/**********************************************************/
/*  函数名称 :  Mp3Reset                                  */
/*  函数功能 ： vs1003硬件复位                            */
/*  参数     :  无                                        */
/*  返回值   :  无                                        */
/*--------------------------------------------------------*/
void Mp3Reset(void)
{	
	Mp3PutInReset();//xReset = 0   复位vs1003      
	wait(200);//延时100ms
	SPIPutChar(0xff);//发送一个字节的无效数据，启动SPI传输
	Mp3DeselectControl();   //xCS = 1
	Mp3DeselectData();     //xDCS = 1
	Mp3ReleaseFromReset(); //xRESET = 1
	wait(200);            //延时100ms
	while (MP3_DREQ == 0);//等待DREQ为高

    wait(200);            //延时100ms
 	Mp3SetVolume(50,50);  
    Mp3SoftReset();//vs1003软复位
}


bool CheckVS1003B_DRQ(void)
{
	bool bResult;

	bResult =MP3_DREQ;
	return(bResult);
}

/***********************************************************/
/*  函数名称 :  VsSineTest                                 */
/*  函数功能 ： vs1003正弦测试，将该函数放在while循环中，  */
/*              如果能持续听到一高一低的声音，证明测试通过 */                            
/*  参数     :  无                                         */
/*  返回值   :  无                                         */
/*---------------------------------------------------------*/
void VsSineTest(void)
{
	Mp3PutInReset();  //xReset = 0   复位vs1003
	wait(200);        //延时100ms        
	SPIPutChar(0xff);//发送一个字节的无效数据，启动SPI传输
	Mp3DeselectControl();  
	Mp3DeselectData();     
	Mp3ReleaseFromReset(); 
	wait(200);	               
	Mp3SetVolume(50,50);  

 	Mp3WriteRegister(SPI_MODE,0x08,0x20);//进入vs1003的测试模式
	while (MP3_DREQ == 0);     //等待DREQ为高
 	Mp3SelectData();       //xDCS = 1，选择vs1003的数据接口
 	
 	//向vs1003发送正弦测试命令：0x53 0xef 0x6e n 0x00 0x00 0x00 0x00
 	//其中n = 0x24, 设定vs1003所产生的正弦波的频率值，具体计算方法见vs1003的datasheet
   	SPIPutChar(0x53);      
	SPIPutChar(0xef);      
	SPIPutChar(0x6e);      
	SPIPutChar(0x24);      
	SPIPutChar(0x00);      
	SPIPutChar(0x00);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
//	wait(500);
	wait(250);
	wait(250);
	Mp3DeselectData();//程序执行到这里后应该能从耳机听到一个单一频率的声音
  
        //退出正弦测试
	Mp3SelectData();
	SPIPutChar(0x45);
	SPIPutChar(0x78);
	SPIPutChar(0x69);
	SPIPutChar(0x74);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
//	wait(500);
	wait(250);
	wait(250);

	Mp3DeselectData();

        //再次进入正弦测试并设置n值为0x44，即将正弦波的频率设置为另外的值
    Mp3SelectData();       
	SPIPutChar(0x53);      
	SPIPutChar(0xef);      
	SPIPutChar(0x6e);      
	SPIPutChar(0x44);      
	SPIPutChar(0x00);      
	SPIPutChar(0x00);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
//	wait(500);
	wait(250);
	wait(250);

	Mp3DeselectData(); 

	//退出正弦测试
	Mp3SelectData();
	SPIPutChar(0x45);
	SPIPutChar(0x78);
	SPIPutChar(0x69);
	SPIPutChar(0x74);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
	SPIPutChar(0x00);
//	wait(500);
	wait(250);
	wait(250);

	Mp3DeselectData();
 }

void test_1003_PlayMP3File();

void TestVS1003B(void)
{
//	Mp3Reset();
//	VsSineTest();
//	Mp3SoftReset();
	test_1003_PlayMP3File();
}

//写寄存器，参数，地址和数据
void VS1003B_WriteCMD(unsigned char addr, unsigned int dat)
{
/*
	VS1003B_XDCS_H();
	VS1003B_XCS_L();
	VS1003B_WriteByte(0x02);
	//delay_Nus(20);
	VS1003B_WriteByte(addr);
	VS1003B_WriteByte(dat>>8);
	VS1003B_WriteByte(dat);
	//delay_Nus(200);
	VS1003B_XCS_H();
*/
	Mp3WriteRegister(addr,dat>>8,dat);
}

//读寄存器，参数 地址 返回内容
unsigned int VS1003B_ReadCMD(unsigned char addr)
{
/*
	unsigned int temp;
	unsigned char temp1;
	VS1003B_XDCS_H();
	VS1003B_XCS_L();
	VS1003B_WriteByte(0x03);
	//delay_Nus(20);
	VS1003B_WriteByte(addr);
	temp=  VS1003B_ReadByte();
	temp=temp<<8;
	temp1= VS1003B_ReadByte();
	temp=temp|temp1;;
	VS1003B_XCS_H();
	return temp;
*/
	return(Mp3ReadRegister(addr));
}

//写数据，音乐数据
void VS1003B_WriteDAT(unsigned char dat)
{
//	VS1003B_XDCS_L();
//	VS1003B_WriteByte(dat);
//	VS1003B_XDCS_H();
//	VS1003B_XCS_H();

   	Mp3SelectData();
	SPIPutChar(dat);
	Mp3DeselectData();
	Mp3DeselectControl();

}

//开启环绕声
void VS1003B_SetVirtualSurroundOn(void)
{
	uchar ucRepeatCount;
	uint uiModeValue;

	ucRepeatCount =0;

	while(1)//写时钟寄存器
	{
		uiModeValue = VS1003B_ReadCMD(0x00);
		if(uiModeValue & 0x0001)
		{
			break;
		}
		else
		{
			uiModeValue |= 0x0001;
			VS1003B_WriteCMD(0,uiModeValue);
		}
		ucRepeatCount++;
		if(ucRepeatCount++ >10 )break;
	}

}

//关闭环绕声
void VS1003B_SetVirtualSurroundOff(void)
{
	uchar ucRepeatCount;
	uint uiModeValue;

	ucRepeatCount =0;

	while(1)//写时钟寄存器
	{
		uiModeValue = VS1003B_ReadCMD(0x00);
		if(uiModeValue & 0x0001)
		{
			break;
		}
		else
		{
			uiModeValue |= 0x0001;
			VS1003B_WriteCMD(0,uiModeValue);
		}
		ucRepeatCount++;
		if(ucRepeatCount++ >10 )break;
	}

}

//增强重音
//入口参数	1.强度0-15
//			2.频率0-15 (X10Hz)
void VS1003B_SetBassEnhance(uchar ucValue, ucFrequencyID)
{
	uchar ucRepeatCount;
	uint uiWriteValue;
	uint uiReadValue;	

	ucRepeatCount =0;

	uiWriteValue = VS1003B_ReadCMD(0x02);

	uiWriteValue &= 0xFF00;
	uiWriteValue |= ucValue<<4;
	uiWriteValue &= (ucFrequencyID & 0x0F);

	while(1)//写时钟寄存器
	{

		VS1003B_WriteCMD(2,uiWriteValue);
		uiReadValue = VS1003B_ReadCMD(0x02);
		
		if(uiReadValue == uiWriteValue)
		{
			break;
		}
		ucRepeatCount++;
		if(ucRepeatCount++ >10 )break;
	}

}


 uint uiVolumeCount=99;		//当前音量值

//VS1003初始化，0成功 1失败
unsigned char VS1003B_Init()
{
	unsigned char retry;
/*
	PORT_INI();
	DDRB|=0xa0;
	VS1003B_DDR &=~(1<<VS1003B_DREQ);
	//delay_Nus(50);
	VS1003B_XCS_H();
	VS1003B_XDCS_H();
	VS1003B_XRESET_L();
	VS1003B_Delay(0xffff);
	VS1003B_XRESET_H();//使能芯片
	VS1003B_SPI_Low();//先以低频操作
	VS1003B_Delay(0xffff);//延时
*/
Mp3Reset();

	retry=0;
	while(VS1003B_ReadCMD(0x00) != 0x0800)//写mode寄存器
	{
		VS1003B_WriteCMD(0x00,0x0800);
		if(retry++ >10 )break;//{PORTB|=_BV(PB1);break;}
	}
	retry=0;
	/*while(VS1003B_ReadCMD(0x02) != 0x75)//写mode寄存器
	{
		VS1003B_WriteCMD(0x02,0x75);
		if(retry++ >10 )break;//{PORTB|=_BV(PB1);break;}
	}*/
	retry=0;
	while(VS1003B_ReadCMD(0x03) != 0x9800)//写时钟寄存器
	{
		VS1003B_WriteCMD(0x03,0x9800);
		if(retry++ >10 )break;
	}
	retry=0;
//	while(VS1003B_ReadCMD(0x0b) != 0x1111)//设音量
//	{
//		VS1003B_WriteCMD(0x0b,0x1111);
//		if(retry++ >10 )break;
//	}
	while(VS1003B_ReadCMD(0x0b) != uiVolumeCount)//设音量
	{
		VS1003B_WriteCMD(0x0b,uiVolumeCount);
		if(retry++ >10 )break;
	}

	//VS1003B_SPI_High();//提高速度，全速运行
	if(retry > 10)return 1;
	return 0;
}

//VS1003软件复位
void VS1003B_SoftReset()
{
	VS1003B_WriteCMD(0x00,0x0804);//写复位
//	VS1003B_Delay(0xffff);//延时，至少1.35ms
	wait(2);
}

void VS1003B_Fill2048Zero()
{
	unsigned char i,j;

	for(i=0;i<64;i++)
	{
		if(CheckVS1003B_DRQ())
		{
			Mp3SelectData();

			for(j=0;j<32;j++)
			{

				VS1003B_WriteDAT(0x00);
			}
			Mp3DeselectData();
		}
	}
}

code unsigned char MusicData[] = 
{
	0xff, 0xe3, 0x18, 0xc0, 0x0, 0xc, 0x91, 0xa9, 0x18, 0x1, 0x81, 0x10, 0x0, 0xff, 0xef, 0xfd, 0xc, 
0x4b, 0xfc, 0x6d, 0xf, 0xff, 0xee, 0x46, 0x72, 0x7f, 0xff, 0xee, 0x8c, 0x73, 0x37, 0xff, 0xff, 
0x9f, 0x62, 0x8e, 0x20, 0xa0, 0x4f, 0xff, 0x33, 0x87, 0x3, 0xe0, 0x3f, 0xff, 0xe8, 0x2, 0x69, 
0x47, 0xff, 0xfe, 0x1f, 0x32, 0xfc, 0xca, 0x1f, 0xff, 0xff, 0xf3, 0x46, 0x43, 0x6, 0x95, 0xff, 
0x28, 0x5a, 0x0, 0xbf, 0xf0, 0x2b, 0x8b, 0xff, 0xe3, 0x18, 0xc0, 0x8, 0xe, 0x2a, 0x3e, 0xd8, 
0x1, 0x8a, 0x50, 0x0, 0x63, 0xc1, 0x53, 0xfc, 0xb1, 0x52, 0x77, 0xff, 0xec, 0x79, 0xe7, 0x9a, 
0x70, 0xcf, 0xfd, 0xbf, 0x84, 0x90, 0x23, 0x24, 0x54, 0x6a, 0xff, 0xff, 0xf9, 0x38, 0xfe, 0xee, 
0x9f, 0xff, 0xff, 0xfe, 0x34, 0x3c, 0xf6, 0x33, 0x31, 0x87, 0xef, 0xff, 0xff, 0x42, 0x2b, 0xff, 
0xff, 0xe4, 0xd1, 0xa8, 0xca, 0xb9, 0x81, 0x40, 0x36, 0x6, 0x28, 0xed, 0x24, 0x6, 0x18, 0xff, 
0xe3, 0x18, 0xc0, 0xa, 0xc, 0xd1, 0x46, 0xe8, 0x1, 0xcd, 0x28, 0x0, 0xd0, 0xc5, 0x4, 0x8d, 
0x92, 0x49, 0x24, 0x91, 0x65, 0x25, 0xeb, 0x7f, 0xfe, 0xaf, 0xae, 0xad, 0x2a, 0x48, 0x8c, 0x31, 
0x8c, 0x6f, 0xff, 0xf9, 0xde, 0x12, 0x11, 0x8, 0x7f, 0xea, 0x40, 0x13, 0xfe, 0xba, 0x8f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x5a, 0xaa, 0xac, 0x68, 0x5, 0x64, 0x60, 0x56, 0x45, 0x4a, 0x83, 0xad, 
0x17, 0xfd, 0xfd, 0x42, 0xa7, 0xff, 0x4f, 0xff, 0xe3, 0x18, 0xc0, 0x11, 0x10, 0xa1, 0xe2, 0xe0, 
0x0, 0x68, 0x90, 0x70, 0xdb, 0xe4, 0x23, 0x2a, 0x23, 0x1c, 0xff, 0xff, 0xff, 0xd6, 0xae, 0x28, 
0x15, 0x18, 0x2f, 0x3, 0x8f, 0x84, 0xa7, 0xdf, 0xff, 0xff, 0x8e, 0x25, 0x54, 0xa5, 0x1f, 0x52, 
0x31, 0x29, 0xc8, 0xb8, 0x14, 0x8, 0x1c, 0xa6, 0x91, 0x50, 0x9d, 0x5b, 0xbf, 0xff, 0xff, 0xfd, 
0xdf, 0x57, 0xfe, 0xda, 0x10, 0x8a, 0xd4, 0xa0, 0x3a, 0x1b, 0x4, 0xe, 0xc6, 0x3d, 0x97, 0xff, 
0xe3, 0x18, 0xc0, 0x9, 0xd, 0x19, 0xea, 0xdc, 0x0, 0x38, 0x4e, 0x70, 0xf7, 0xf4, 0x94, 0xff, 
0xff, 0xff, 0x29, 0x70, 0x18, 0xdf, 0xff, 0xff, 0xcd, 0x9e, 0x6b, 0xb, 0xc2, 0x8b, 0x7f, 0xff, 
0xd6, 0x6f, 0x4b, 0x9c, 0x22, 0x8e, 0x5, 0x44, 0x93, 0xbf, 0xfe, 0xaf, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x16, 0x25, 0xff, 0xd1, 0x32, 0xcd, 0x35, 0x8b, 0xa1, 0x84, 0x38, 0xcd, 0xb7, 0x17, 0x17, 
0x7, 0xfe, 0x3f, 0xd1, 0xc8, 0x0, 0x0, 0xff, 0xe3, 0x18, 0xc0, 0xf, 0xb, 0xe9, 0x7a, 0xd8, 
0x0, 0x58, 0x84, 0x4c, 0x20, 0x9f, 0xff, 0xfd, 0x3c, 0xa8, 0x60, 0x22, 0x9f, 0xff, 0xff, 0xf2, 
0xb1, 0x8d, 0x1c, 0xe0, 0x1, 0xcf, 0xff, 0xd2, 0xdf, 0xff, 0xf7, 0x56, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xeb, 0x4a, 0xda, 0x54, 0x4, 0x6e, 0x90, 0x2a, 0x8e, 0xa5, 0xfb, 0xaf, 0xfa, 
0x78, 0x8f, 0xd4, 0xe1, 0x60, 0xf8, 0x14, 0x87, 0xa4, 0xf5, 0xcc, 0xb1, 0x93, 0x7b, 0xc7, 0xff, 
0xe3, 0x18, 0xc0, 0x1a, 0x13, 0x29, 0x7e, 0xcc, 0x0, 0x5a, 0xc, 0x4c, 0xb2, 0x17, 0xfd, 0xc9, 
0xd3, 0x35, 0x24, 0xdb, 0x25, 0xad, 0x9f, 0x7e, 0x6c, 0x94, 0x2c, 0xc, 0xe9, 0xd0, 0x49, 0x3d, 
0x3d, 0xdf, 0x1f, 0xfd, 0x6d, 0xf4, 0x71, 0x2d, 0x57, 0xad, 0x64, 0xe, 0x2c, 0xf7, 0x5a, 0xbf, 
0xfd, 0xb7, 0x8b, 0x9f, 0xd7, 0xff, 0xb3, 0xff, 0xff, 0xff, 0xd7, 0x4b, 0xbf, 0xff, 0x5d, 0xff, 
0xfc, 0x4f, 0xff, 0x0, 0x27, 0x26, 0x0, 0xff, 0xe3, 0x18, 0xc0, 0x8, 0xd, 0xb9, 0x46, 0xe5, 
0x94, 0x49, 0x44, 0x4c, 0xd3, 0xec, 0xb1, 0xfc, 0x4b, 0x7d, 0xc7, 0xff, 0xe4, 0x7e, 0x8e, 0x6e, 
0xab, 0xab, 0xb3, 0x41, 0xff, 0xff, 0x4c, 0xe7, 0x13, 0xff, 0xf5, 0xaa, 0x2, 0x81, 0x38, 0xaf, 
0xf1, 0xce, 0xb4, 0x55, 0x8e, 0x2b, 0xaf, 0xb7, 0x58, 0x89, 0x3f, 0xf9, 0x27, 0xff, 0xff, 0xdc, 
0xa7, 0xfe, 0x2a, 0xa, 0x5f, 0xfc, 0xf6, 0x3a, 0x98, 0x42, 0x9a, 0x5f, 0x25, 0xec, 0xad, 0xff, 
0xe3, 0x18, 0xc0, 0xc, 0xc, 0x59, 0x4a, 0xc4, 0x0, 0x10, 0xcc, 0x4c, 0xad, 0xe9, 0x8a, 0x63, 
0x96, 0x4c, 0xa4, 0x6c, 0x24, 0x6a, 0x38, 0x6c, 0xd1, 0x46, 0xec, 0x5c, 0x6d, 0x3b, 0xeb, 0x7f, 
0x33, 0x17, 0x0, 0x68, 0x59, 0x49, 0xa3, 0x67, 0x5f, 0xb6, 0x6f, 0x58, 0x48, 0xf0, 0xf7, 0x3d, 
0x42, 0xd5, 0x55, 0x37, 0xae, 0x63, 0x8e, 0x9a, 0x69, 0x56, 0x14, 0x1, 0x11, 0x20, 0xba, 0xfc, 
0xe4, 0xab, 0xda, 0xc6, 0xa3, 0xad, 0xbd, 0xff, 0xe3, 0x18, 0xc0, 0x15, 0xc, 0xe1, 0xb6, 0xb4, 
0x1, 0x47, 0x18, 0x0, 0x3a, 0x67, 0x98, 0xab, 0xeb, 0x7d, 0x4d, 0xaf, 0xe, 0xed, 0x2b, 0xc2, 
0xf4, 0x6, 0xdb, 0x69, 0x48, 0x97, 0xce, 0x9f, 0xcc, 0xca, 0x6e, 0xc8, 0xe0, 0x84, 0xbb, 0x6d, 
0xdd, 0xf9, 0x65, 0xff, 0xef, 0x47, 0x9e, 0x79, 0x31, 0xb8, 0x4a, 0x13, 0x32, 0xf8, 0xdc, 0x89, 
0x72, 0x3, 0x83, 0x63, 0x8c, 0xfc, 0x5f, 0xce, 0xd1, 0xca, 0xdf, 0xf2, 0x34, 0x8d, 0x39, 0xff, 
0xe3, 0x18, 0xc0, 0x1c, 0x14, 0x2, 0x32, 0xe8, 0x1, 0x87, 0x28, 0x0, 0xc0, 0x49, 0x8a, 0x53, 
0x19, 0xbf, 0xff, 0x66, 0x90, 0x95, 0x47, 0x6c, 0xb5, 0x4f, 0xff, 0x42, 0x10, 0x5c, 0xee, 0x46, 
0x62, 0x29, 0xd9, 0x55, 0x4a, 0x51, 0x21, 0xef, 0x2, 0x7f, 0x77, 0xe0, 0xad, 0x21, 0x85, 0xa0, 
0x5f, 0xff, 0xf7, 0x19, 0xcc, 0xa6, 0xf5, 0x84, 0x0, 0xae, 0xd9, 0xff, 0xff, 0x66, 0x12, 0x14, 
0xe8, 0xed, 0xfb, 0x89, 0x81, 0xd1, 0xce, 0xff, 0xe3, 0x18, 0xc0, 0x7, 0xc, 0x80, 0xe6, 0xe4, 
0x1, 0xc7, 0x10, 0x0, 0xe8, 0xfd, 0xd1, 0xe, 0x65, 0x5a, 0xf5, 0xf6, 0xff, 0xb9, 0x30, 0x44, 
0x5e, 0x1c, 0x55, 0x69, 0xbf, 0xf0, 0x98, 0x35, 0xff, 0x76, 0xa7, 0x7f, 0xd6, 0xc7, 0x20, 0xf7, 
0xfc, 0xb0, 0xba, 0xad, 0xab, 0xff, 0x57, 0x6b, 0x3c, 0xd7, 0xd1, 0xb7, 0xf7, 0xdd, 0xe9, 0xe4, 
0x27, 0xfc, 0x50, 0xf3, 0x7e, 0xba, 0x0, 0x69, 0xfd, 0x5b, 0xfd, 0x15, 0x90, 0xe3, 0x54, 0xff, 
0xe3, 0x18, 0xc0, 0x10, 0xb, 0xc0, 0xfe, 0xe0, 0x0, 0x9, 0x4e, 0x48, 0x45, 0x22, 0x3a, 0x81, 
0x41, 0x87, 0xfa, 0x50, 0xe5, 0x29, 0xfc, 0x2d, 0xff, 0xee, 0x21, 0xff, 0xff, 0xe7, 0xba, 0x90, 
0xba, 0x88, 0x87, 0x82, 0xa7, 0xff, 0xfe, 0xff, 0xff, 0xbd, 0x8, 0x0, 0x30, 0x3f, 0xc3, 0xc0, 
0x3f, 0xff, 0xff, 0xfe, 0x22, 0xe, 0xbf, 0xff, 0xff, 0xfa, 0x82, 0x73, 0x3f, 0xfd, 0x3f, 0xff, 
0x94, 0x22, 0xab, 0x7f, 0xfd, 0x7f, 0xef, 0xff, 0xe3, 0x18, 0xc0, 0x1c, 0xd, 0x1a, 0xd6, 0xe9, 
0x95, 0x45, 0x10, 0x0, 0x8b, 0x52, 0xb7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0x61, 0xd4, 
0xdf, 0xff, 0x83, 0xc7, 0x7f, 0xfd, 0xe0, 0xf0, 0x4f, 0xff, 0xe9, 0xf3, 0x2a, 0xff, 0xff, 0xeb, 
0xd3, 0x42, 0x66, 0x29, 0xc9, 0x2, 0x60, 0xc1, 0x26, 0x62, 0x3c, 0x8d, 0xb6, 0x77, 0xdb, 0xed, 
0xb2, 0x9f, 0x15, 0xb, 0x3f, 0x1f, 0x2d, 0xf6, 0x66, 0x4c, 0xcf, 0x13, 0x9e, 0xff, 0xca, 0xff, 
0xe3, 0x18, 0xc0, 0x22, 0x15, 0xbb, 0xc6, 0xc8, 0x1, 0x8d, 0x38, 0x0, 0x9c, 0x5f, 0x5d, 0xa8, 
0x89, 0x98, 0x9d, 0x5f, 0xfd, 0xf7, 0xf3, 0xf3, 0xcf, 0xfb, 0x73, 0xa6, 0x17, 0x6e, 0xcf, 0x13, 
0x0, 0xe0, 0x9c, 0x9b, 0xe, 0x39, 0xbd, 0x74, 0x2a, 0xe8, 0xbf, 0xfd, 0xff, 0x9c, 0x22, 0xa1, 
0xed, 0xea, 0xa2, 0x9f, 0xd7, 0x4f, 0xd7, 0xff, 0xff, 0x93, 0x3c, 0xe3, 0x56, 0xe1, 0xd6, 0xdd, 
0xd7, 0xff, 0xff, 0xe9, 0xe7, 0x32, 0x84, 0xff, 0xe3, 0x18, 0xc0, 0x6, 0xb, 0xb1, 0x42, 0xd8, 
};

void test_1003_PlayMP3File() 
{
   unsigned int data_pointer;unsigned char i;
	unsigned int uiCount;

	uiCount = sizeof(MusicData);
	data_pointer=0; 
	VS1003B_SoftReset();
    while(uiCount>0)
  	{ 
	   if(CheckVS1003B_DRQ())
      	{
    		for(i=0;i<32;i++)
           	{
     			VS1003B_WriteDAT(MusicData[data_pointer]);
     			data_pointer++;
            }
			uiCount -= 32;
         }
    }
	VS1003B_Fill2048Zero();
}
